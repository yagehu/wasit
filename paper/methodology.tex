\section{Methodology}
\label{sec:method}
%
\begin{figure*}
\centering
\input{figures/workflow.tex}
\caption{The \wazzi{} differential testing workflow.}
\label{fig:workflow}
\end{figure*}
%
\wazzi{} aims to semi-automate uncovering platform-specific \wasi{}
implementation bugs in \wasm{} runtimes.
%
In Fig. \ref{fig:workflow} we present the workflow of \wazzi{}, which consists
of three automated phases:
\begin{enumerate*}[label=(\arabic*)]
    \item interface analysis,
    \item call generation, and
    \item differential execution.
\end{enumerate*}
%
During the interface analysis phase, \wazzi{} parses an annotated \wasi{}
specification to establish the semantic constraints of each function.
%
With these semantic constraints, the call generation phase selects an
appropriate \wasi{} function to call and prepares interesting inputs.
%
Then, in differential execution phase, \wazzi{} executes the generated call,
checks outputs and side effects, and minimizes the problematic call sequence if
it finds a behavioral divergence.
%
Starting with a motivating example, we elaborate on why \wazzi{} can overcome
challenges in previous solutions.
%
We then describe the overall workflow of \wazzi{} and its major components.
%
\subsection{Motivating Example}
%
\begin{figure}
\begin{subfigure}{0.23\textwidth}
\begin{lstlisting}[
    language=C,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle={},
    commentstyle=\color{blue},
    numbers=left,
    escapeinside={<@}{@>},
]
int fd0 = <@\textbf{open}@>(
    "file",
    O_WRONLY | O_APPEND
);
<@\textbf{write}@>(
    fd0,
    critical_data,
    len
);
off_t offset = <@\textbf{lseek}@>(
    fd0, 0, SEEK_CUR);
<@\textbf{close}@>(fd0);

int fd1 = <@\textbf{open}@>(
    "file",
    O_WRONLY
);
<@\textbf{pwrite}@>(
    fd1,
    data,
    data_len,
    offset
);
\end{lstlisting}
\caption{Application code in C.}
\label{fig:lseek-example-c}
\end{subfigure}%
%
\begin{subfigure}{0.25\textwidth}
\begin{lstlisting}[
    basicstyle=\ttfamily\footnotesize,
    morekeywords={call},
    keywordstyle=\color{blue},
    morecomment={[n]{(;}{;)}},
    commentstyle=\color{gray},
    escapeinside={<@}{@>},
]
(call <@\textbf{\$path\_open}@>
  (; args omitted ;)
  (i32.const 0) (; fd0 ;))
(call <@\textbf{\$fd\_write}@>
  (i32.load 0) (; fd0 ;)
  (; omitted ;))
(call <@\textbf{\$fd\_tell}@>
  (i32.load 0) (; fd0 ;)
  (i32.const 4)
    (; offset ;))
(call <@\textbf{\$fd\_close}@>
  (i32.load 0) (; fd0 ;))

(call <@\textbf{\$path\_open}@>
  (; args omitted ;)
  (i32.const 0) (; fd1 ;))
(call <@\textbf{\$fd\_pwrite}@>
  (; args omitted ;)
  (i32.const 0) (; fd1 ;)
  (; omitted ;)
  (i64.load 4)
    (; offset ;))
\end{lstlisting}
\caption{Compiled to WASI.}
\label{fig:lseek-example-wasm}
\end{subfigure}%
%
\caption{Simplified example of application relying correct \texttt{lseek} behavior.}
\label{fig:lseek-example}
\end{figure}
%
Many real-world applications depend on filesystem services and implicitly rely
on filesystem-related syscalls behaving as expected for correctness.
%
Fig. \ref{fig:lseek-example-c} shows a simplified example of a C application
relying the correction behavior of \texttt{lseek} on line 10 to ensure a later
\texttt{pwrite} does not corrupt important data.
%
Fig \ref{fig:lseek-example-wasm} shows the same example compiled to \wasm{} with
\wasi{} support.
%
In this example, the behavior of \texttt{lseek(fd0, 0 , SEEK\_CUR)}, and its
corresponding \wasi{} function \texttt{fd\_tell} depends on not only the values
of its arguments, but also hidden system state they represent.
%
Specifically, \texttt{fd0} is just an integer file descriptor, but the resource
it represents---an open file description---contains information passed to a
previous \texttt{open} syscall on line 1; in this case, the file access mode
\texttt{O\_WRONLY} and the flag \texttt{O\_APPEND}.
%
\par
%
In a bug discovered by \wazzi{}, one \wasm{} runtime will, in the presence of
the \texttt{O\_APPEND} flag during opening a file, always return offset as $0$
regardless of the actual offset. Such a behavior violates the contract between
application developer and the OS. In this case, the errant behavior is a result
of the \wasm{} runtime emulating parts of the filesystem layer and incorrectly
handling the append flag.
%
\par
%
In this example, a hypothetical differential fuzzer can spot the bug after the
\texttt{lseek()} by generating a precise
\texttt{open}--\texttt{write}--\texttt{lseek} call sequence.
%
However, prior techniques lack the semantic awareness to generate such call
sequences.
%
For example, WADIFF~\cite{wadiff} generates \wasm{} binaries targeting a single
instruction, and thus can only uncover inconsistencies at the instruction level.
%
\subsection{Overall Workflow}
%
\subsection{Interface Analysis}
%
\subsection{Call Generation}
%
\subsection{Differential Execution}

